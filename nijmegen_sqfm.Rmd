---
  title: "Software quality and formal methods: Hoare/Dijkstra approach"
  author: "Dr. Ivan S. Zapreev"
  institute: "Neat Software Designs"
  date: "`r format(Sys.Date())`"
  output:
    beamer_presentation:
      slide_level: 2
      theme: "Hannover"
      colortheme: "lily"
      fonttheme: "professionalfonts"
---

---
**Global Outline:**

+ Software Quality
+ Programming Languages
+ Formal Methods
+ Frama - C
+ Verification in practice
+ Concluding remarks

# Software Quality

## Software Quality: Outline

* Our Motivation
* Software Development
* Software Verification

## Our Motivation: Therac-25

* Years **`1985`--`1987`**:
    * Radiation therapy overdose
    * Control software flaw:
        * Race conditions
    * Death of `6` (six) cancer patients

![Radiation therapy](./images/therac-25.png){height=70%}


## Our Motivation: Ariane-5
    
* Year **`1996`**:
    * Missile crash
    * Control software flaw:
        * `64`-bit float to `16`-bit int
    * $`7` billion development program
    * $`500` million cargo

![Space flights](./images/ariane-5.jpg){height=70%}

## Our Motivation: Toyota Camry

* Year **`2005`**
    * Sudden unintended acceleration:
    * Control software flaw:
        * Recursion causing stack overflow
    * `89` deaths and `57` injuries
    * $`1.2` billion compensations

![Automobiles](./images/camry.jpg){height=80%}
    
## Our Motivation: Plenty More

The 12 Software Bugs That Caused Epic Failures:  [$\underline{\color{blue}{\text{<link>}}}$](https://www.testbytes.net/blog/12-software-bugs-that-caused-epic-failure/)

![](./images/bugs_everywhere.png){height=70%}

## Software Development: V-model

![Software development process](./images/v_model.png){height=70%}

## Software Development: V & V
Is formally defined in, e.g.: [`ISO-9000:2015`](https://www.iso.org/obp/ui/#iso:std:iso:9000:ed-4:v1:en:term:3.8.12):

* **Verification** -- *"Confirmation, through the provision of objective evidence, that specified requirements have been fulfilled."*
* **Validation** -- *"Confirmation, through the provision of objective evidence, that the requirements for a specific intended use or application have been fulfilled."*

## Software Development: Testing

* **Verification**:
    * Are we building the product right?
    * Does the system comply with its specification?
* **Validation**:
    * Are we building the right product?
    * Does the system meet the needs of the customer?

![Devision of testing types](./images/testing.png){height=50%}

## Formal Verification

**Facts:**

* No globally recognized definition of Formal Methods[^1].
* Local attempts to have one[^2], e.g.:

>"Formal methods are techniques used to model complex systems as mathematical entities."

>"By building a rigorous model of a complex system, it is possible to verify the system's properties in a more thorough fashion than empirical testing."

[^1]: "Formal Methods for Industrial Critical Systems", S. Gnesi, T. Margaria
[^2]: ["Formal Methods", Michael Collins, CMU](https://users.ece.cmu.edu/~koopman/des_s99/formal_methods/)

**Conclusion:**

Formal methods are techniques suitable for Verification.

## Software Verification

**Goal:**

A program shall satisfy a formal specification of its behavior.

![Verification methods](./images/verification_techniques.png){height=60%}

# Programming Languages

## Programming Languages: Outline

* Language generations
* Declarative vs. Imperative
* What is ANSI-C?

## Language generations

![Generations of Programming languages](./images/languages.png){height=70%}
  
## Declarative vs. Imperative: Main

* *Declarative* -- Expresses what to accomplish without specifying concrete steps.
```{js, eval=F}
    //Declarative `JavaScript`
    var arr_dbl = arr.map((x) => x * 2)
```
* *Imperative* -- Describes computation in terms of statements that change a program state.
```{js, eval=F}
    //Imperative `JavaScript`
    var arr_dbl = []
    for (let i = 0; i < arr.length; i++) {
      arr_dbl.push(arr[i] * 2)
    }
```

## Declarative vs. Imperative: Test

![If you laugh, it means you've passed](./images/imp-decl-joke.png){height=110%}

## What is ANSI-C: Old C

**Procedural language:**

Is an imperative language in which the program is built from one or more subroutines commonly known as `functions`. 

**`C` language:**

`C` is an *imperative* *procedural* language.

**Defining ANSI-C:**

`ANSI-C` is a common name for two equivalent language specs:

* `C89` by American National Standards Institute (ANSI)
* `C90` by International Organization for Standardization (ISO) 

# Formal Methods

## Formal Methods: Outline

* Formal Verification
* Hoare Approach
* Dijkstra Extension

## Formal verification

**Question:** Does formal *validation* exist?

![Formal correctness proving](./images/verification_techniques_marked.png){height=55%}

*Prove* conformance to specifications for *imperative programs*.

## Hoare Approach[^3]

**Hoare triples**: $\left\{P\right\}C\left\{Q\right\}$

$C$ - code; $P$ - pre-condition; $Q$ - post-condition;

**Axioms**, e.g. *Skip* and *Assign*: 
$$\textstyle{\frac{-}{\left\{P\right\} skip \left\{P\right\}}\;\text{and}\;\frac{-}{\left\{P\left[E/V\right]\right\} V := E \left\{P\right\}}}$$
Where $E$ is any expression and $V$ is any variable.

**Inference rules**, e.g. *Composition* and *Conditional*:
$$\textstyle{\frac{\left\{P\right\}S_{1}\left\{R\right\},\;\left\{R\right\}S_{2}\left\{Q\right\}}{\left\{P\right\}S_{1};\;S_{2}\left\{Q\right\}}\;\text{and}\;\frac{\left\{B\wedge P\right\}S\left\{Q\right\},\;\left\{\lnot B\wedge P\right\}T\left\{Q\right\}}{\left\{P\right\}\;\mathbf{if}\;B\;\mathbf{then}\;S\;\mathbf{else}\;T\;\mathbf{elseif}\;\left\{Q\right\}}}$$

**Partial correctness:**
If $P$ holds before executing $C$ then $Q$ holds afterwards, ONLY if $C$ terminates.

[^3]: "An Axiomatic Basis for Computer Programming", Tony Hoare, 1969.

## Dijkstra Extension[^4]

The *weakest precondition calculus* for 

* A predicate transform semantics to mechanize the proofs.
* Explains how $C$ transforms $P$ into $Q$. 

**Backward reasoning**:

* Based on $Q$ and $C$ calculate the *weakest pre-condition* $\widehat{P}$ 
* If $P \implies \widehat{P}$, then the proof is complete

**Forward reasoning**:

* Based on $P$ and $C$ calculate the *strongest post-condition* $\widehat{Q}$ 
* If $\widehat{Q} \implies Q$, then the proof is complete

[^4]: "Guarded commands, non-determinacy and formal derivation of programs", Edsger Dijkstra, 1975
  
# Frama - C

## Frama - C: Outline

* Platform description
* Plugins overview
* What is ACSL?
  
## Platform description

A plug-in-based open-source cross-platform framework for `C` source-code analysis:

* Browsing unfamiliar code
* Static code analysis
* Dynamic code analysis
* Code transformations
* Certification of critical software

You can easily build upon the existing plug-ins to implement your own analysis. 

## Plugins overview: Main

![Frama-C plugins](./images/frama-c.png)

## Plugins overview: WP

WP -- *weakest precondition* for ACSL specs of ANSI-C programs.

![Frama-C WP plugin](./images/frama-c-wp.png){height=70%}

## What is ACSL: General

In short:

* ACSL -- ANSI/ISO C Specification Language
* Allows to formally specify properties of a C program

It is all about function contracts:

```{c, eval=F}
  /*@ ensures \result >= x && \result >= y;
      ensures \result == x || \result == y;
   */
  int max (int x, int y) {
    return(x > y) ? x : y;
  }
```

A function contract is a combination of:

* post-conditions - `ensures`
* pre-conditions - `requires`

## What is ACSL: Pointers

ACSL allows to reason about, e.g.:

* Pointers
* Arrays
* Termination

Consider pointers:

```{c, eval=F}
  /*@ requires \valid(p) && \valid(q);
      ensures *p <= *q;
   */
  void max_ptr (int *x, int *y) {
    if(*x >*y) {
      int tmp =*x;
      *x =*y;
      *y = tmp;
    }
  }
```

## What is ACSL: Completeness

Is the following `max_ptr` implementation correct?

```{c, eval=F}
  /*@ requires \valid(p) && \valid(q);
      ensures *p <= *q;
   */
  void max_ptr (int *x, int *y) {
    *p = *q = 0;
  }
```

The is the following specification *complete*?

```{c, eval=F}
  /*@ requires \valid(p) && \valid(q);
      ensures *p <= *q;
      ensures (*p == \old(*p) && *q == \old(*q)) ||
              (*p == \old(*q) && *q == \old(*p));
   */
  void max_ptr(int*p, int*q);
```

## What is ACSL: The whole spec.

The complete specification *v1.4* has `93` pages:
https://frama-c.com/download/acsl_1.4.pdf

![Feel free to explore](./images/homer.jpg){height=60%}

# Verification in practice

## Verification in practice: Outline

* Verification Examples
* Verification Outcomes
* The morale

## Verification Examples



## Verification Outcomes

If the proof is $\color{blue}{\bf{OK}}$:

* The program satisfies the specification
* *Is the specification correct/complete?*

If the proof is $\color{red}{\bf{NOK}}$:

* An *incorrect implementation*
    * Find counter-example via test generation;
* A *wrong specification*
    * Complete spec. and proof analysis;
    * Change/extend the specification;
* A *prover's failure*
    * Alternative provers;
    * Interactive proof assistants;
  
## The morale
    
![It is not so easy but ... ](./images/easy.jpg){height=70%}

# Concluding remarks
  
* We had an overview of 

* Questions?
